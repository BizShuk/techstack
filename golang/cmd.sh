#!/bin/bash

# [GOGC], it will cause gc event when the heap grow value percentage, default 100(%)
MODULE_NAME=""
TESTCASE_NAME=""
COVERAGE_REPORT="out/cover.out"
COVERAGE_MODE="count"
# [GOTRACEBACK] panic info, from single message to stack
GOTRACEBACK=single # none, single[default], all, system, crash
# [GOMAXPROCS] value that controls the number of operating system threads allocated to goroutines in your program
GOMAXPROCS=4 # the number of CPUs[default]
# [GODEBUG] for trace purpose, [GC] [Memory] [Schefuler]


# SetMaxStack ???
# GetGCStats ???

### Mod
go mod init ${MODULE_NAME}
go mod tidy
go get -u ${MODULE_NAME}

### Testing
go test -run ${TESTCASE_NAME}
go test -v ./...    # Test all under current package
go test -covermode=${COVERAGE_MODE}  -coverprofile=${COVERAGE_REPORT} <package> # Generate test coverage report
go test --cpuprofile=<profile name> <package>
go test --memprofile=<profile name> <package>

### Build
go build -gcflags '[pattern=]arg list' # args will pass to go tool compile
go build -gcflags "-m -l" # print optimization decision, -m will be passed to

# Tool
### cover
go tool cover -func out/cover.out # View test coverage report by func
### compile
go tool compile -help
go tool compile -m=2 # print optimization decision
### pprof output
go tool pprof --text <file name> <profile file>
go tool pprof --web  <profile file>
go tool pprof --list <funcname> <profile file>
go tool pprof --text mybin  http://myserver:6060:/debug/pprof/profile
### trace
go tool trace <trace_file> # trace file generated by -trace=trace.out in go test cmd


time go build
go clean -cache
free cmd
top cmd
